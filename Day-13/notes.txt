1. Why goroutines weren't printing anything.
Problem:
When you launch goroutines in main and main finishes immediately, the entire program exits → all goroutines are killed before they can do (or finish) their work.
Example of the issue:
func main() {
    go Greet("World!")
    go slowGreet("slow...")
    // main ends → program dies → nothing or almost nothing prints
}
Solution:
Make main wait for all goroutines to complete before exiting.Common ways:
1.time.Sleep(...) (quick & dirty, not recommended for production)
2.sync.WaitGroup (clean, idiomatic, recommended)
3.Channels (good when you want to collect results or handle errors)

2. sync.WaitGroup – Deep Understanding
Purpose:
Wait for a group of goroutines to finish their work.
Core Concept
Maintains a single internal counter:
1.Add(n) → increases counter
2.Done() → decreases counter by 1
3.Wait() → blocks until counter reaches 0

Internal Implementation (simplified):
1.Uses one 64-bit atomic integer (state)
2.Upper 32 bits:counter (pending tasks)
3..Lower bits: waiter count + semaphore bits
4..All operations are atomic → lock-free & very efficient

Correct & Safe Pattern (Most Recommended)

var wg sync.WaitGroup

wg.Add(4)
go worker("A", &wg)
go worker("B", &wg)
go worker("C", &wg)
go worker("D", &wg)

wg.Wait() // blocks until all 4 Done() calls happen

Inside each worker:

func worker(name string, wg *sync.WaitGroup) {
    defer wg.Done()           // guaranteed to run (even on panic)
    // do work...
}
Important Rules
1.Call Add() before starting the goroutine
2.Call Done() exactly once per Add()
3.Use defer wg.Done() for safety (panic-proof)
4.Never call Done() more times than Add() → panic (negative counter)

3. Correct Pattern for Launching Goroutines in a Loop
Wrong (classic bug)

for i := 0; i < 10; i++ {
    go func() {
        fmt.Println(i)     // All goroutines will most likely print 10!
    }()
}
Why it fails?
-All goroutines capture the same loop variable i (closure captures reference).
By the time they run, loop is finished → i == 10.

Correct & Safe Ways
-Way 1 – Pass as parameter (Most recommended)
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        fmt.Println("Worker", id)
        // work...
    }(i)               // ← pass copy of i
}
wg.Wait()

-Way 2 – Create local copy
for i := 0; i < 10; i++ {
    wg.Add(1)
    id := i
    go func() {
        defer wg.Done()
        fmt.Println("Worker", id)
    }()
}


4. defer Keyword – Complete Explanation
What it does
-Schedules a function call to run just before the surrounding function returns (normal return, early return, or panic).

Key Characteristics
1.Arguments are evaluated immediately, but call is delayed
2.Multiple defers run in LIFO (Last-In-First-Out) order
3.Always runs — even if panic occurs
4.Perfect for cleanup: close files, unlock mutexes, call wg.Done(), etc.

Classic Examples
func processFile() error {
    f, err := os.Open("data.txt")
    if err != nil {
        return err
    }
    defer f.Close()           // guaranteed cleanup

    // ... work with file
    return nil
}

mutex.Lock()
defer mutex.Unlock()          // safe unlock even on panic

With WaitGroup (why we love defer)
go func() {
    defer wg.Done()           // runs even if panic happens inside
    // risky work...
}()


Summary Table – defer
Feature                     Behavior
When executed          Just before function returns
Multiple defers        Run in reverse order (LIFO)
Panic safety           Yes – defers run during panic unwind
Argument evaluation    At the time defer is written
Most common uses       Cleanup, logging, Done(), unlock


5. Channels – Basic Concept & Philosophy
-What is a channel?
A typed conduit (pipe) for safe communication and synchronization between goroutines.
-Core Philosophy
"Do not communicate by sharing memory;
instead, share memory by communicating."

Two main types
1.Unbuffered (make(chan int))  
-Synchronous  
-Sender blocks until receiver is ready  
-Receiver blocks until sender sends
  → Perfect for direct hand-off / rendezvous

2.Buffered (make(chan int, 10))  
-Asynchronous (up to capacity)  
-Sender blocks only when buffer is full  
-Receiver blocks only when buffer is empty

Basic Operations:
ch <- value       // send
value := <-ch     // receive
close(ch)         // sender usually closes when done


Range over channel (very common)
for job := range jobs {
    // process job
}
// loop exits automatically when channel is closed

Best Practices
-Sender is responsible for closing the channel
-Receive-only / send-only channels improve safety & readability
func producer(ch chan<- int) { ... }   // can only send
func consumer(ch <-chan int) { ... }   // can only receive


=> Concurrency vs Parallelism – Clear & Important Explanation

1.Concurrency:
-Definition = Dealing with multiple tasks that can make progress independently (logical multitasking)
-Main goal = Manage many things "at once" (better responsiveness, I/O efficiency)
-Requires = Good design, scheduling, synchronization
-Can exist without = Parallelism (single core can be concurrent)
-Example in real life = Chef cooking 5 dishes: switching between them
-In Go = Goroutines + channels + scheduler
-GOMAXPROCS = Controls how many OS threads Go uses
-Typical bottleneck =I/O waits, locks, bad scheduling
-Classic example = Web server handling 10,000 requests (mostly waiting for DB/network)



1.Parallelism:
-Definition = Actually executing multiple tasks at the exact same time (physical simultaneous execution)
-Main goal = Maximize speed / throughput using multiple CPU cores
-Requires = Multiple CPU cores / hardware threads
-Can exist without =Concurrency (you can do parallelism badly)
-Example in real life = 5 chefs each cooking one dish at the same time
-In Go = Goroutines running on multiple OS threads
-GOMAXPROCS = Directly affects whether you get real parallelism
-Typical bottleneck = CPU-bound work that can't be split
-Classic example = Image processing / video encoding on 16 cores

Key memorable phrases
-Concurrency = "dealing with lots of things at once" (illusion or real)  
-Parallelism = "doing lots of things at once" (must be physically simultaneous)


In Go (very practical view):
// This is CONCURRENCY (many tasks, but maybe not parallel)
for i := 0; i < 10000; i++ {
    go handleRequest(i)   // thousands of goroutines
}

// This can become PARALLELISM
// (if GOMAXPROCS > 1 and CPU-bound work)
runtime.GOMAXPROCS(16)    // use up to 16 OS threads
for i := 0; i < 100; i++ {
    go heavyMathComputation(i)  // real parallel work on 16 cores
}

Quick rule of thumb:
-Most real-world Go programs are concurrent first (web servers, APIs, CLI tools, message processors)  
-They become parallel only when doing heavy CPU work (image processing, ML training, simulations, video encoding)


One-liner summary:
-Concurrency is about structure and correctness (how you organize tasks).
Parallelism is about performance and hardware (how fast they actually run).










  