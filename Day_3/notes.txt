âš¡ Compile Time vs Runtime (Clear & Practical):

ğŸ› ï¸ Compile time:
This is the phase when your source code is translated into machine code (or bytecode).
It happens before the program runs.
âœ… What happens at compile time?
- Syntax checking (missing semicolons, wrong types)
- Type checking
- Code optimization
- Generating the executable or bytecode
âœ… Compile-time errors include:
- Syntax errors
- Type mismatch
- Missing files
- Incorrect function signatures
ğŸ–¥ï¸ Example:
var x int  = "hello";  // compile-time error
âœ… Key idea:
The compiler refuses to run your program until all compile-time errors are fixed.




ğŸš€ Runtime
This is when the compiled program is executed.
âœ… What happens at runtime?
- Memory allocation
- User input handling
- File/network access
- Dynamic behavior
- Exceptions
âœ… Runtime errors include:
- Null pointer dereference
- Division by zero
- Out-of-bounds access
- File not found
- Network failure
ğŸ–¥ï¸ Example:
package main

import "fmt"

func main() {
    a := 10
    b := 0

    fmt.Println(a / b) // runtime panic: integer divide by zero
}
âœ… Key idea:
-Runtime errors occur only when the program is actually runningâ€”the compiler cannot detect them
If you run this, Go will compile fine (no compile-time error), but at runtime it will panic with something like:
panic: runtime error: integer divide by zero

ğŸ§© Comparison:
1.Compile Time:
-when it happens: before execution
-who handles it: compiler
-errors: syntax, type error
-memory: mostly stack/static
-examples: missing semicolon

2.Runtime:
-when it happens: during execution
-who handles it: cpu + os
-errors: exceptions, crashes 
-memory: heap, dynamic allocation
-examples: null pointer, divide by zero




ğŸ§  A Simple Analogy
Think of writing a book:
- Compile time = Editor checks grammar, spelling, structure
- Runtime = Readers actually read the book and encounter issues like missing pages or plot holes

If you want, I can also explain:
âœ… compile-time vs runtime polymorphism
âœ… compile-time vs runtime memory
âœ… compile-time vs runtime binding

 Compile-time vs Runtime Polymorphism
- Compile-time: Decided by the compiler before running (e.g., method overloading, generics).
- Runtime: Decided while the program runs (e.g., interfaces, inheritance, dynamic dispatch).

ğŸ”¹ Compile-time vs Runtime Memory
- Compile-time: Fixed memory decided at compile time (stack, static variables).
- Runtime: Allocated while program runs (heap, dynamic objects, garbage collection).

ğŸ”¹ Compile-time vs Runtime Binding
- Compile-time (early binding): Function calls resolved at compile time (direct calls).
- Runtime (late binding): Function calls resolved at runtime (virtual functions, interface calls).

ğŸ‘‰ Think of it like this:
- Compile-time = fixed, known in advance.
- Runtime = flexible, decided on the fly

